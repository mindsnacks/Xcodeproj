require 'fileutils'
require 'rexml/document'

module Xcodeproj

	# Provides support for generating, reading and serializing Xcode Workspace
	# documents.
	#
	class Workspace

		# Generic tree-link container mixin. 
		# 
		module Container

			attr_reader :contents

			# Adds a object to the list of the of contents of this Container.
			#
			# @param  [Object] item
			#         The object to add.
			#
			# @return [void]
			#
			def <<(item)
				@contents << item 
			end

			def traverse(node = self, &block)
				yield node
				node.contents.each { |child| traverse(child, &block) } if node.is_a? Container 
			end

		end

		# Defines types of items that can be contained within a Workspace
		# 
		module WorkspaceItem

			# Abstract base class for WorkspaceItems
			# 
			class AbstractWorkspaceItem

				# @return [String] the ISA of the class.
				#
				def self.isa
					@isa ||= name.split('::').last
				end

				# @return [String] the object's class name.
				#
				attr_reader :isa

				def initialize()
					@isa = self.class.isa
				end

				# @return [REXML::Node] the XML representation of the WorkspaceItem
				# 
				def to_xml
					raise "Must be implemented by subclasses."
					nil
				end
			end

			# Represents a 'FileRef' in the Workspace. This is most commonly used to
			# reference xcodeproj files, but is it not limited to them.
			# 
			class FileRef < AbstractWorkspaceItem

				attr_accessor :path

				def initialize(path=nil)
					@isa = self.class.isa
					@path = path
				end

				def to_xml
					el = REXML::Element.new("FileRef")
					el.attributes["location"] = "group:" + @path
					el 
				end

				include Comparable
				
				def <=>(other_fileref)
					if self.path < other_fileref.path
						-1
					elsif self.path > other_fileref.path
						1
					else
						0
					end
				end

			end

			# Represents a 'Group' in the Workspace. Like Groups in Xcode projects,
			# Groups in Workspaces exist only within the context of the Workspace,
			# and do not map to any on-disk folders. They are for organizational
			# purposes only.
			#
			class Group < AbstractWorkspaceItem

				# Group objects are Containers.
				# 
				include Container

				def initialize()
					@isa = self.class.isa
					@contents = []
				end

			end
		end

		# Workspace objects are Containers.
		# 
		include Container

		# @return [Array<String>] the paths of the projects contained in the
		#   workspace.
		#
		def projpaths
			projpaths = []
			traverse do |item| 
				if item.is_a? WorkspaceItem::FileRef and item.path.end_with? 'xcodeproj'
					projpaths << item.path
				end
			end
			projpaths
		end

		def initialize
			@contents = []
		end

		# @param  [String] projpaths @see projpaths
		#
		def initialize(*contents)
			@contents = []

			contents.each do |item|
				if item.is_a? WorkspaceItem::AbstractWorkspaceItem
					@contents << item
				elsif item.is_a? String
					@contents << WorkspaceItem::FileRef.new(item)
				end
			end
		end

		# Returns a workspace generated by reading the contents of the given path.
		#
		# @param  [String] path
		#         the path of the `xcworkspace` file.
		#
		# @return [Workspace] the generated workspace.
		#
		def self.new_from_xcworkspace(path)
			begin
				from_s(File.read(File.join(path, 'contents.xcworkspacedata')))
			rescue Errno::ENOENT
				new
			end
		end

		# Returns a workspace generated by reading the contents of the given
		# XML representation.
		#
		# @param [String] xml
		#   the XML representation of the workspace.
		#
		# @return [Workspace] the generated workspace.
		#
		def self.from_s(xml)
			document = REXML::Document.new(xml)
			projpaths = document.get_elements("/Workspace/FileRef").map do |node|
				node.attribute("location").to_s.sub(/^group:/, '')
			end
			new(*projpaths)
		end

		# Adds a new item to the contents of the workspace.
		#
		# @param  [String | AbstractWorkspaceItem] item 
		# 	If a String is inserted, it will automatically be converted to a
		# 	FileRef. WorkspaceItems are inserted, as-is. Any other type of object
		# 	is not allowed.
		#
		# @return [void]
		#
		def <<(item)
			if item.is_a? String
				super << WorkspaceItem::FileRef.new(item)
			elsif item.is_a? WorkspaceItem::AbtractWorkspaceItem
				super << item
			else
				raise "Attempt to insert unsupported object type in Workspace."
			end
		end

		# Checks if the workspace contains the project with the given path.
		#
		# @param  [String] projpath
		#         The path of the project to add.
		#
		# @return [Boolean] whether the project is contained in the workspace.
		#
		def include?(projpath)
			target = WorkspaceItem::FileRef.new(projpath)
			self.traverse { |item| return true if item == target }
			false
		end

		# The template to generate a workspace XML representation.
		#
		TEMPLATE = %q[<?xml version="1.0" encoding="UTF-8"?><Workspace version="1.0"></Workspace>]

		# @return [String] the XML representation of the workspace.
		#
		def to_s
			REXML::Document.new(TEMPLATE).tap do |document|
				document.context[:attribute_quote] = :quote # use double quotes
				@contents.each do |item|
					document.root << item.to_xml
				end
			end.to_s
		end

		# Saves the workspace at the given `xcworkspace` path.
		#
		# @param  [String] path
		#         the path where to save the project.
		#
		# @return [void]
		#
		def save_as(path)
			FileUtils.mkdir_p(path)
			File.open(File.join(path, 'contents.xcworkspacedata'), 'w') do |out|
				out << to_s
			end
		end

	end
end
